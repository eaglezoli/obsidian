/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@electron/remote/dist/src/renderer/callbacks-registry.js
var require_callbacks_registry = __commonJS({
  "node_modules/@electron/remote/dist/src/renderer/callbacks-registry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallbacksRegistry = void 0;
    var CallbacksRegistry = class {
      constructor() {
        this.nextId = 0;
        this.callbacks = {};
        this.callbackIds = /* @__PURE__ */ new WeakMap();
        this.locationInfo = /* @__PURE__ */ new WeakMap();
      }
      add(callback) {
        let id = this.callbackIds.get(callback);
        if (id != null)
          return id;
        id = this.nextId += 1;
        this.callbacks[id] = callback;
        this.callbackIds.set(callback, id);
        const regexp = /at (.*)/gi;
        const stackString = new Error().stack;
        if (!stackString)
          return id;
        let filenameAndLine;
        let match;
        while ((match = regexp.exec(stackString)) !== null) {
          const location = match[1];
          if (location.includes("(native)"))
            continue;
          if (location.includes("(<anonymous>)"))
            continue;
          if (location.includes("callbacks-registry.js"))
            continue;
          if (location.includes("remote.js"))
            continue;
          if (location.includes("@electron/remote/dist"))
            continue;
          const ref = /([^/^)]*)\)?$/gi.exec(location);
          if (ref)
            filenameAndLine = ref[1];
          break;
        }
        this.locationInfo.set(callback, filenameAndLine);
        return id;
      }
      get(id) {
        return this.callbacks[id] || function() {
        };
      }
      getLocation(callback) {
        return this.locationInfo.get(callback);
      }
      apply(id, ...args) {
        return this.get(id).apply(global, ...args);
      }
      remove(id) {
        const callback = this.callbacks[id];
        if (callback) {
          this.callbackIds.delete(callback);
          delete this.callbacks[id];
        }
      }
    };
    exports.CallbacksRegistry = CallbacksRegistry;
  }
});

// node_modules/@electron/remote/dist/src/common/type-utils.js
var require_type_utils = __commonJS({
  "node_modules/@electron/remote/dist/src/common/type-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserialize = exports.serialize = exports.isSerializableObject = exports.isPromise = void 0;
    var electron_1 = require("electron");
    function isPromise(val) {
      return val && val.then && val.then instanceof Function && val.constructor && val.constructor.reject && val.constructor.reject instanceof Function && val.constructor.resolve && val.constructor.resolve instanceof Function;
    }
    exports.isPromise = isPromise;
    var serializableTypes = [
      Boolean,
      Number,
      String,
      Date,
      Error,
      RegExp,
      ArrayBuffer
    ];
    function isSerializableObject(value) {
      return value === null || ArrayBuffer.isView(value) || serializableTypes.some((type) => value instanceof type);
    }
    exports.isSerializableObject = isSerializableObject;
    var objectMap = function(source, mapper) {
      const sourceEntries = Object.entries(source);
      const targetEntries = sourceEntries.map(([key, val]) => [key, mapper(val)]);
      return Object.fromEntries(targetEntries);
    };
    function serializeNativeImage(image) {
      const representations = [];
      const scaleFactors = image.getScaleFactors();
      if (scaleFactors.length === 1) {
        const scaleFactor = scaleFactors[0];
        const size = image.getSize(scaleFactor);
        const buffer = image.toBitmap({ scaleFactor });
        representations.push({ scaleFactor, size, buffer });
      } else {
        for (const scaleFactor of scaleFactors) {
          const size = image.getSize(scaleFactor);
          const dataURL = image.toDataURL({ scaleFactor });
          representations.push({ scaleFactor, size, dataURL });
        }
      }
      return { __ELECTRON_SERIALIZED_NativeImage__: true, representations };
    }
    function deserializeNativeImage(value) {
      const image = electron_1.nativeImage.createEmpty();
      if (value.representations.length === 1) {
        const { buffer, size, scaleFactor } = value.representations[0];
        const { width, height } = size;
        image.addRepresentation({ buffer, scaleFactor, width, height });
      } else {
        for (const rep of value.representations) {
          const { dataURL, size, scaleFactor } = rep;
          const { width, height } = size;
          image.addRepresentation({ dataURL, scaleFactor, width, height });
        }
      }
      return image;
    }
    function serialize(value) {
      if (value && value.constructor && value.constructor.name === "NativeImage") {
        return serializeNativeImage(value);
      }
      if (Array.isArray(value)) {
        return value.map(serialize);
      } else if (isSerializableObject(value)) {
        return value;
      } else if (value instanceof Object) {
        return objectMap(value, serialize);
      } else {
        return value;
      }
    }
    exports.serialize = serialize;
    function deserialize(value) {
      if (value && value.__ELECTRON_SERIALIZED_NativeImage__) {
        return deserializeNativeImage(value);
      } else if (Array.isArray(value)) {
        return value.map(deserialize);
      } else if (isSerializableObject(value)) {
        return value;
      } else if (value instanceof Object) {
        return objectMap(value, deserialize);
      } else {
        return value;
      }
    }
    exports.deserialize = deserialize;
  }
});

// node_modules/@electron/remote/dist/src/common/get-electron-binding.js
var require_get_electron_binding = __commonJS({
  "node_modules/@electron/remote/dist/src/common/get-electron-binding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getElectronBinding = void 0;
    var getElectronBinding = (name) => {
      if (process._linkedBinding) {
        return process._linkedBinding("electron_common_" + name);
      } else if (process.electronBinding) {
        return process.electronBinding(name);
      } else {
        return null;
      }
    };
    exports.getElectronBinding = getElectronBinding;
  }
});

// node_modules/@electron/remote/dist/src/common/module-names.js
var require_module_names = __commonJS({
  "node_modules/@electron/remote/dist/src/common/module-names.js"(exports) {
    "use strict";
    var _a;
    var _b;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.browserModuleNames = exports.commonModuleNames = void 0;
    var get_electron_binding_1 = require_get_electron_binding();
    exports.commonModuleNames = [
      "clipboard",
      "nativeImage",
      "shell"
    ];
    exports.browserModuleNames = [
      "app",
      "autoUpdater",
      "BaseWindow",
      "BrowserView",
      "BrowserWindow",
      "contentTracing",
      "crashReporter",
      "dialog",
      "globalShortcut",
      "ipcMain",
      "inAppPurchase",
      "Menu",
      "MenuItem",
      "nativeTheme",
      "net",
      "netLog",
      "MessageChannelMain",
      "Notification",
      "powerMonitor",
      "powerSaveBlocker",
      "protocol",
      "pushNotifications",
      "safeStorage",
      "screen",
      "session",
      "ShareMenu",
      "systemPreferences",
      "TopLevelWindow",
      "TouchBar",
      "Tray",
      "utilityProcess",
      "View",
      "webContents",
      "WebContentsView",
      "webFrameMain"
    ].concat(exports.commonModuleNames);
    var features = get_electron_binding_1.getElectronBinding("features");
    if (((_a = features === null || features === void 0 ? void 0 : features.isDesktopCapturerEnabled) === null || _a === void 0 ? void 0 : _a.call(features)) !== false) {
      exports.browserModuleNames.push("desktopCapturer");
    }
    if (((_b = features === null || features === void 0 ? void 0 : features.isViewApiEnabled) === null || _b === void 0 ? void 0 : _b.call(features)) !== false) {
      exports.browserModuleNames.push("ImageView");
    }
  }
});

// node_modules/@electron/remote/dist/src/renderer/remote.js
var require_remote = __commonJS({
  "node_modules/@electron/remote/dist/src/renderer/remote.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFunctionWithReturnValue = exports.getGlobal = exports.getCurrentWebContents = exports.getCurrentWindow = exports.getBuiltin = void 0;
    var callbacks_registry_1 = require_callbacks_registry();
    var type_utils_1 = require_type_utils();
    var electron_1 = require("electron");
    var module_names_1 = require_module_names();
    var get_electron_binding_1 = require_get_electron_binding();
    var { Promise: Promise2 } = global;
    var callbacksRegistry = new callbacks_registry_1.CallbacksRegistry();
    var remoteObjectCache = /* @__PURE__ */ new Map();
    var finalizationRegistry = new FinalizationRegistry((id) => {
      const ref = remoteObjectCache.get(id);
      if (ref !== void 0 && ref.deref() === void 0) {
        remoteObjectCache.delete(id);
        electron_1.ipcRenderer.send("REMOTE_BROWSER_DEREFERENCE", contextId, id, 0);
      }
    });
    var electronIds = /* @__PURE__ */ new WeakMap();
    var isReturnValue = /* @__PURE__ */ new WeakSet();
    function getCachedRemoteObject(id) {
      const ref = remoteObjectCache.get(id);
      if (ref !== void 0) {
        const deref = ref.deref();
        if (deref !== void 0)
          return deref;
      }
    }
    function setCachedRemoteObject(id, value) {
      const wr = new WeakRef(value);
      remoteObjectCache.set(id, wr);
      finalizationRegistry.register(value, id);
      return value;
    }
    function getContextId() {
      const v8Util = get_electron_binding_1.getElectronBinding("v8_util");
      if (v8Util) {
        return v8Util.getHiddenValue(global, "contextId");
      } else {
        throw new Error("Electron >=v13.0.0-beta.6 required to support sandboxed renderers");
      }
    }
    var contextId = process.contextId || getContextId();
    process.on("exit", () => {
      const command = "REMOTE_BROWSER_CONTEXT_RELEASE";
      electron_1.ipcRenderer.send(command, contextId);
    });
    var IS_REMOTE_PROXY = Symbol("is-remote-proxy");
    function wrapArgs(args, visited = /* @__PURE__ */ new Set()) {
      const valueToMeta = (value) => {
        if (visited.has(value)) {
          return {
            type: "value",
            value: null
          };
        }
        if (value && value.constructor && value.constructor.name === "NativeImage") {
          return { type: "nativeimage", value: type_utils_1.serialize(value) };
        } else if (Array.isArray(value)) {
          visited.add(value);
          const meta = {
            type: "array",
            value: wrapArgs(value, visited)
          };
          visited.delete(value);
          return meta;
        } else if (value instanceof Buffer) {
          return {
            type: "buffer",
            value
          };
        } else if (type_utils_1.isSerializableObject(value)) {
          return {
            type: "value",
            value
          };
        } else if (typeof value === "object") {
          if (type_utils_1.isPromise(value)) {
            return {
              type: "promise",
              then: valueToMeta(function(onFulfilled, onRejected) {
                value.then(onFulfilled, onRejected);
              })
            };
          } else if (electronIds.has(value)) {
            return {
              type: "remote-object",
              id: electronIds.get(value)
            };
          }
          const meta = {
            type: "object",
            name: value.constructor ? value.constructor.name : "",
            members: []
          };
          visited.add(value);
          for (const prop in value) {
            meta.members.push({
              name: prop,
              value: valueToMeta(value[prop])
            });
          }
          visited.delete(value);
          return meta;
        } else if (typeof value === "function" && isReturnValue.has(value)) {
          return {
            type: "function-with-return-value",
            value: valueToMeta(value())
          };
        } else if (typeof value === "function") {
          return {
            type: "function",
            id: callbacksRegistry.add(value),
            location: callbacksRegistry.getLocation(value),
            length: value.length
          };
        } else {
          return {
            type: "value",
            value
          };
        }
      };
      return args.map(valueToMeta);
    }
    function setObjectMembers(ref, object, metaId, members) {
      if (!Array.isArray(members))
        return;
      for (const member of members) {
        if (Object.prototype.hasOwnProperty.call(object, member.name))
          continue;
        const descriptor = { enumerable: member.enumerable };
        if (member.type === "method") {
          const remoteMemberFunction = function(...args) {
            let command;
            if (this && this.constructor === remoteMemberFunction) {
              command = "REMOTE_BROWSER_MEMBER_CONSTRUCTOR";
            } else {
              command = "REMOTE_BROWSER_MEMBER_CALL";
            }
            const ret = electron_1.ipcRenderer.sendSync(command, contextId, metaId, member.name, wrapArgs(args));
            return metaToValue(ret);
          };
          let descriptorFunction = proxyFunctionProperties(remoteMemberFunction, metaId, member.name);
          descriptor.get = () => {
            descriptorFunction.ref = ref;
            return descriptorFunction;
          };
          descriptor.set = (value) => {
            descriptorFunction = value;
            return value;
          };
          descriptor.configurable = true;
        } else if (member.type === "get") {
          descriptor.get = () => {
            const command = "REMOTE_BROWSER_MEMBER_GET";
            const meta = electron_1.ipcRenderer.sendSync(command, contextId, metaId, member.name);
            return metaToValue(meta);
          };
          if (member.writable) {
            descriptor.set = (value) => {
              const args = wrapArgs([value]);
              const command = "REMOTE_BROWSER_MEMBER_SET";
              const meta = electron_1.ipcRenderer.sendSync(command, contextId, metaId, member.name, args);
              if (meta != null)
                metaToValue(meta);
              return value;
            };
          }
        }
        Object.defineProperty(object, member.name, descriptor);
      }
    }
    function setObjectPrototype(ref, object, metaId, descriptor) {
      if (descriptor === null)
        return;
      const proto = {};
      setObjectMembers(ref, proto, metaId, descriptor.members);
      setObjectPrototype(ref, proto, metaId, descriptor.proto);
      Object.setPrototypeOf(object, proto);
    }
    function proxyFunctionProperties(remoteMemberFunction, metaId, name) {
      let loaded = false;
      const loadRemoteProperties = () => {
        if (loaded)
          return;
        loaded = true;
        const command = "REMOTE_BROWSER_MEMBER_GET";
        const meta = electron_1.ipcRenderer.sendSync(command, contextId, metaId, name);
        setObjectMembers(remoteMemberFunction, remoteMemberFunction, meta.id, meta.members);
      };
      return new Proxy(remoteMemberFunction, {
        set: (target, property, value) => {
          if (property !== "ref")
            loadRemoteProperties();
          target[property] = value;
          return true;
        },
        get: (target, property) => {
          if (property === IS_REMOTE_PROXY)
            return true;
          if (!Object.prototype.hasOwnProperty.call(target, property))
            loadRemoteProperties();
          const value = target[property];
          if (property === "toString" && typeof value === "function") {
            return value.bind(target);
          }
          return value;
        },
        ownKeys: (target) => {
          loadRemoteProperties();
          return Object.getOwnPropertyNames(target);
        },
        getOwnPropertyDescriptor: (target, property) => {
          const descriptor = Object.getOwnPropertyDescriptor(target, property);
          if (descriptor)
            return descriptor;
          loadRemoteProperties();
          return Object.getOwnPropertyDescriptor(target, property);
        }
      });
    }
    function metaToValue(meta) {
      if (!meta)
        return {};
      if (meta.type === "value") {
        return meta.value;
      } else if (meta.type === "array") {
        return meta.members.map((member) => metaToValue(member));
      } else if (meta.type === "nativeimage") {
        return type_utils_1.deserialize(meta.value);
      } else if (meta.type === "buffer") {
        return Buffer.from(meta.value.buffer, meta.value.byteOffset, meta.value.byteLength);
      } else if (meta.type === "promise") {
        return Promise2.resolve({ then: metaToValue(meta.then) });
      } else if (meta.type === "error") {
        return metaToError(meta);
      } else if (meta.type === "exception") {
        if (meta.value.type === "error") {
          throw metaToError(meta.value);
        } else {
          throw new Error(`Unexpected value type in exception: ${meta.value.type}`);
        }
      } else {
        let ret;
        if ("id" in meta) {
          const cached = getCachedRemoteObject(meta.id);
          if (cached !== void 0) {
            return cached;
          }
        }
        if (meta.type === "function") {
          const remoteFunction = function(...args) {
            let command;
            if (this && this.constructor === remoteFunction) {
              command = "REMOTE_BROWSER_CONSTRUCTOR";
            } else {
              command = "REMOTE_BROWSER_FUNCTION_CALL";
            }
            const obj = electron_1.ipcRenderer.sendSync(command, contextId, meta.id, wrapArgs(args));
            return metaToValue(obj);
          };
          ret = remoteFunction;
        } else {
          ret = {};
        }
        setObjectMembers(ret, ret, meta.id, meta.members);
        setObjectPrototype(ret, ret, meta.id, meta.proto);
        if (ret.constructor && ret.constructor[IS_REMOTE_PROXY]) {
          Object.defineProperty(ret.constructor, "name", { value: meta.name });
        }
        electronIds.set(ret, meta.id);
        setCachedRemoteObject(meta.id, ret);
        return ret;
      }
    }
    function metaToError(meta) {
      const obj = meta.value;
      for (const { name, value } of meta.members) {
        obj[name] = metaToValue(value);
      }
      return obj;
    }
    function hasSenderId(input) {
      return typeof input.senderId === "number";
    }
    function handleMessage(channel, handler) {
      electron_1.ipcRenderer.on(channel, (event, passedContextId, id, ...args) => {
        if (hasSenderId(event)) {
          if (event.senderId !== 0 && event.senderId !== void 0) {
            console.error(`Message ${channel} sent by unexpected WebContents (${event.senderId})`);
            return;
          }
        }
        if (passedContextId === contextId) {
          handler(id, ...args);
        } else {
          electron_1.ipcRenderer.send("REMOTE_BROWSER_WRONG_CONTEXT_ERROR", contextId, passedContextId, id);
        }
      });
    }
    var enableStacks = process.argv.includes("--enable-api-filtering-logging");
    function getCurrentStack() {
      const target = { stack: void 0 };
      if (enableStacks) {
        Error.captureStackTrace(target, getCurrentStack);
      }
      return target.stack;
    }
    handleMessage("REMOTE_RENDERER_CALLBACK", (id, args) => {
      callbacksRegistry.apply(id, metaToValue(args));
    });
    handleMessage("REMOTE_RENDERER_RELEASE_CALLBACK", (id) => {
      callbacksRegistry.remove(id);
    });
    exports.require = (module3) => {
      const command = "REMOTE_BROWSER_REQUIRE";
      const meta = electron_1.ipcRenderer.sendSync(command, contextId, module3, getCurrentStack());
      return metaToValue(meta);
    };
    function getBuiltin(module3) {
      const command = "REMOTE_BROWSER_GET_BUILTIN";
      const meta = electron_1.ipcRenderer.sendSync(command, contextId, module3, getCurrentStack());
      return metaToValue(meta);
    }
    exports.getBuiltin = getBuiltin;
    function getCurrentWindow() {
      const command = "REMOTE_BROWSER_GET_CURRENT_WINDOW";
      const meta = electron_1.ipcRenderer.sendSync(command, contextId, getCurrentStack());
      return metaToValue(meta);
    }
    exports.getCurrentWindow = getCurrentWindow;
    function getCurrentWebContents() {
      const command = "REMOTE_BROWSER_GET_CURRENT_WEB_CONTENTS";
      const meta = electron_1.ipcRenderer.sendSync(command, contextId, getCurrentStack());
      return metaToValue(meta);
    }
    exports.getCurrentWebContents = getCurrentWebContents;
    function getGlobal(name) {
      const command = "REMOTE_BROWSER_GET_GLOBAL";
      const meta = electron_1.ipcRenderer.sendSync(command, contextId, name, getCurrentStack());
      return metaToValue(meta);
    }
    exports.getGlobal = getGlobal;
    Object.defineProperty(exports, "process", {
      enumerable: true,
      get: () => exports.getGlobal("process")
    });
    function createFunctionWithReturnValue(returnValue) {
      const func = () => returnValue;
      isReturnValue.add(func);
      return func;
    }
    exports.createFunctionWithReturnValue = createFunctionWithReturnValue;
    var addBuiltinProperty = (name) => {
      Object.defineProperty(exports, name, {
        enumerable: true,
        get: () => exports.getBuiltin(name)
      });
    };
    module_names_1.browserModuleNames.forEach(addBuiltinProperty);
  }
});

// node_modules/@electron/remote/dist/src/renderer/index.js
var require_renderer = __commonJS({
  "node_modules/@electron/remote/dist/src/renderer/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    if (process.type === "browser")
      throw new Error(`"@electron/remote" cannot be required in the browser process. Instead require("@electron/remote/main").`);
    __exportStar(require_remote(), exports);
  }
});

// node_modules/@electron/remote/renderer/index.js
var require_renderer2 = __commonJS({
  "node_modules/@electron/remote/renderer/index.js"(exports, module2) {
    module2.exports = require_renderer();
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CopyImageTextPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var fs = __toESM(require("fs/promises"));
var { dialog } = require_renderer2();
var CopyImageTextPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.lastExportedHtmlPath = null;
  }
  async onload() {
    this.addCommand({
      id: "copy-text",
      name: "\u590D\u5236\u6587\u672C\u548C\u56FE\u7247(\u5BCC\u6587\u672C)",
      editorCallback: (editor, view) => this.copyTextAndImages(editor, view)
    });
    this.addCommand({
      id: "copy-markdown",
      name: "\u590D\u5236\u4E3AMarkdown\u683C\u5F0F",
      editorCallback: (editor, view) => this.copyAsMarkdown(editor, view)
    });
    this.addCommand({
      id: "export-html",
      name: "\u5BFC\u51FA\u4E3AHTML\u6587\u4EF6",
      editorCallback: (editor, view) => this.exportAsHtml(editor, view)
    });
  }
  async copyTextAndImages(editor, view) {
    try {
      let content = editor.getSelection() || editor.getValue();
      if (!view.file) {
        new import_obsidian.Notice("\u65E0\u6CD5\u83B7\u53D6\u5F53\u524D\u6587\u4EF6\u4FE1\u606F\uFF0C\u590D\u5236\u53EF\u80FD\u4E0D\u5B8C\u6574");
        return;
      }
      const htmlContent = await this.convertToHtml(content, view.file);
      await navigator.clipboard.write([
        new ClipboardItem({
          "text/html": new Blob([htmlContent], { type: "text/html" }),
          "text/plain": new Blob([content], { type: "text/plain" })
        })
      ]);
      new import_obsidian.Notice("\u5185\u5BB9\u5DF2\u6210\u529F\u590D\u5236");
    } catch (error) {
      new import_obsidian.Notice("\u590D\u5236\u5931\u8D25\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5");
    }
  }
  async exportAsHtml(editor, view) {
    var _a;
    try {
      let content = editor.getSelection() || editor.getValue();
      if (!view.file) {
        new import_obsidian.Notice("\u65E0\u6CD5\u83B7\u53D6\u5F53\u524D\u6587\u4EF6\u4FE1\u606F\uFF0C\u5BFC\u51FA\u53EF\u80FD\u4E0D\u5B8C\u6574");
        return;
      }
      const htmlContent = await this.convertToHtml(content, view.file);
      const fileName = view.file.basename + ".html";
      const result = await dialog.showOpenDialog({
        properties: ["openDirectory", "createDirectory"],
        title: "\u9009\u62E9HTML\u5BFC\u51FA\u76EE\u5F55",
        defaultPath: ((_a = view.file.parent) == null ? void 0 : _a.path) || ""
      });
      if (result.canceled || result.filePaths.length === 0) {
        new import_obsidian.Notice("\u5DF2\u53D6\u6D88\u5BFC\u51FA\u3002");
        return;
      }
      let exportFolderPath = result.filePaths[0];
      if (exportFolderPath && !exportFolderPath.endsWith("/") && exportFolderPath !== "/") {
        exportFolderPath += "/";
      }
      const filePath = `${exportFolderPath}${fileName}`;
      const vaultRootPath = this.app.vault.getRoot().path;
      const normalizedExportPath = exportFolderPath.endsWith("/") ? exportFolderPath.slice(0, -1) : exportFolderPath;
      const normalizedVaultRootPath = vaultRootPath.endsWith("/") ? vaultRootPath.slice(0, -1) : vaultRootPath;
      const nodeFsPath = exportFolderPath.replace(/\//g, "\\") + fileName;
      await fs.mkdir(exportFolderPath, { recursive: true });
      await fs.writeFile(nodeFsPath, htmlContent);
      new import_obsidian.Notice(`\u6587\u4EF6\u5DF2\u6210\u529F\u5BFC\u51FA\u5230: ${nodeFsPath}`);
      this.lastExportedHtmlPath = filePath;
    } catch (error) {
      new import_obsidian.Notice("\u5BFC\u51FAHTML\u5931\u8D25\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5");
    }
  }
  async copyAsMarkdown(editor, view) {
    try {
      let content = editor.getSelection() || editor.getValue();
      if (!view.file) {
        new import_obsidian.Notice("\u65E0\u6CD5\u83B7\u53D6\u5F53\u524D\u6587\u4EF6\u4FE1\u606F\u590D\u5236\u53EF\u80FD\u4E0D\u5B8C\u6574");
        return;
      }
      content = await this.replaceImageLinks(content, view.file);
      await navigator.clipboard.writeText(content);
      new import_obsidian.Notice("Markdown\u683C\u5F0F\u5DF2\u590D\u5236");
    } catch (error) {
      new import_obsidian.Notice("\u590D\u5236\u5931\u8D25\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5");
    }
  }
  async replaceImageLinks(content, file) {
    const imageRegex = /!\[\[(.*?)\]\]/g;
    let result = content;
    for (const match of content.matchAll(imageRegex)) {
      const imagePath = match[1];
      const imageFile = this.app.vault.getFiles().find((f) => {
        var _a;
        return f.name.toLowerCase().includes(((_a = imagePath.split("/").pop()) == null ? void 0 : _a.toLowerCase()) || "");
      });
      if (imageFile) {
        let absolutePath = this.app.vault.getResourcePath(imageFile).replace(/^app:\/\/.*?\//, "").replace(/\?.*$/, "").replace(/\\/g, "/");
        absolutePath = decodeURI(absolutePath);
        const fileUrl = "file:///" + absolutePath;
        result = result.replace(`![[${imagePath}]]`, `![${imagePath}](${fileUrl})`);
      }
    }
    return result;
  }
  async convertToHtml(content, file) {
    const imageRegex = /!\[\[(.*?)\]\]/g;
    const externalImageRegex = /!\[.*?\]\((file:\/\/\/.+?)\)/g;
    const internalImageReplacements = await Promise.all(Array.from(content.matchAll(imageRegex)).map((match) => this.replaceImageWithBase64(match[1], file)));
    let htmlContent = content;
    htmlContent = htmlContent.replace(/\n\s*\n/g, "\n\n");
    internalImageReplacements.forEach(({ original, replacement }) => {
      htmlContent = htmlContent.replace(original, replacement);
    });
    const externalImageReplacements = await Promise.all(Array.from(htmlContent.matchAll(externalImageRegex)).map((match) => this.replaceExternalImageWithBase64(match[1])));
    externalImageReplacements.forEach(({ original, replacement }) => {
      htmlContent = htmlContent.replace(original, replacement);
    });
    const codeBlockPlaceholders = /* @__PURE__ */ new Map();
    let placeholderIndex = 0;
    htmlContent = htmlContent.replace(/(^|\n)```(\w+)?\n([\s\S]*?)\n(?<!\S)```($|\n)/g, (match, p1, lang, code, p4) => {
      const placeholder = `___CODE_BLOCK_PLACEHOLDER_${placeholderIndex}___`;
      const language = this.getLanguageFromCodeBlock(match[0]);
      const lines = code.split("\n");
      let codeHtml = "";
      for (let i = 0; i < lines.length; i++) {
        const highlightedLine = this.highlightCodeLine(lines[i]);
        codeHtml += `<code><span leaf="">${highlightedLine}</span></code>
`;
      }
      const lineNumbersHtml = Array.from({ length: lines.length }, (_, i) => `<li></li>`).join("\n");
      const codeBlockHtml = `
<section class="code-snippet__js code-snippet__fix code-snippet__${language}">
  <ul class="code-snippet__line-index code-snippet__${language}">
    ${lineNumbersHtml}
  </ul>
  <pre class="code-snippet__js code-snippet code-snippet_nowrap" data-lang="${language}">
    ${codeHtml.trim()}
  </pre>
</section>
      `;
      codeBlockPlaceholders.set(placeholder, codeBlockHtml);
      placeholderIndex++;
      return placeholder;
    });
    htmlContent = htmlContent.replace(/^---$/gm, '<hr style="border: 0; border-top: 1px solid #ddd; margin: 20px 0;">');
    htmlContent = htmlContent.replace(/^(#+)\s+(.*?)$/gm, (match, hashes, title) => {
      const level = hashes.length;
      const fontSize = 28 - level * 2;
      return `<h${level} style="font-size: ${fontSize}px; font-weight: bold; margin: 10px 0;">${title}</h${level}>`;
    });
    htmlContent = htmlContent.replace(/\n/g, "<br>").replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>").replace(/\*(.+?)\*/g, "<em>$1</em>").replace(/`(.+?)`/g, '<code style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">$1</code>');
    htmlContent = htmlContent.replace(/==([^=\n]+?)==/g, (match, p1) => {
      const replaced = `<span style="background-color: yellow;">${p1}</span>`;
      return replaced;
    });
    htmlContent = htmlContent.replace(/(?<!\!)\[(.+?)\]\((.+?)\)/g, '<a href="$2" style="color: #576b95; text-decoration: none;">$1</a>');
    codeBlockPlaceholders.forEach((value, key) => {
      htmlContent = htmlContent.replace(key, value);
    });
    htmlContent = this.cleanAndFormatHtml(htmlContent);
    return `<div style="max-width: 800px; margin: 0 auto; padding: 20px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; color: #333; line-height: 1.6;">${htmlContent}</div>`;
  }
  cleanAndFormatHtml(html) {
    html = html.replace(/>\s+</g, "><");
    html = html.replace(/\n\n+/g, "\n");
    html = html.trim();
    return html;
  }
  async replaceImageWithBase64(imagePath, file) {
    try {
      const fileName = imagePath.split("/").pop() || imagePath;
      const imageFile = this.app.vault.getFiles().find((f) => f.name.toLowerCase().includes(fileName.toLowerCase()));
      if (!imageFile) {
        return { original: `![[${imagePath}]]`, replacement: `[\u56FE\u7247\u672A\u627E\u5230: ${imagePath}]` };
      }
      const stat = await this.app.vault.adapter.stat(imageFile.path);
      if (stat && stat.size > 10 * 1024 * 1024) {
        return { original: `![[${imagePath}]]`, replacement: `[\u56FE\u7247\u6587\u4EF6\u8FC7\u5927: ${imagePath}]` };
      }
      const imageArrayBuffer = await this.app.vault.readBinary(imageFile);
      const base64 = (0, import_obsidian.arrayBufferToBase64)(imageArrayBuffer);
      const mimeType = this.getMimeType(imagePath);
      return {
        original: `![[${imagePath}]]`,
        replacement: `<img src="data:${mimeType};base64,${base64}" alt="${imagePath}" style="max-width: 100%;">`
      };
    } catch (error) {
      return { original: `![[${imagePath}]]`, replacement: `[\u56FE\u7247\u5904\u7406\u9519\u8BEF: ${imagePath}]` };
    }
  }
  async replaceExternalImageWithBase64(imagePath) {
    try {
      let filePath = imagePath.replace(/^file:\/\/\//, "");
      if (process.platform === "win32") {
        filePath = filePath.replace(/\//g, "\\");
      }
      const imageBuffer = await fs.readFile(filePath);
      const base64 = imageBuffer.toString("base64");
      const mimeType = this.getMimeType(filePath);
      return {
        original: `![](${imagePath})`,
        replacement: `<img src="data:${mimeType};base64,${base64}" alt="${imagePath}" style="max-width: 100%;">`
      };
    } catch (error) {
      return { original: `![](${imagePath})`, replacement: `[\u5916\u90E8\u56FE\u7247\u5904\u7406\u9519\u8BEF: ${imagePath}]` };
    }
  }
  getMimeType(filename) {
    var _a;
    const ext = (_a = filename.split(".").pop()) == null ? void 0 : _a.toLowerCase();
    switch (ext) {
      case "jpg":
      case "jpeg":
        return "image/jpeg";
      case "png":
        return "image/png";
      case "gif":
        return "image/gif";
      case "webp":
        return "image/webp";
      case "svg":
        return "image/svg+xml";
      default:
        return "image/png";
    }
  }
  getLanguageFromCodeBlock(codeBlockHeader) {
    const match = codeBlockHeader.match(/```(\w+)?/);
    return match && match[1] ? match[1] : "js";
  }
  highlightCodeLine(line) {
    let processedLine = line.replace(/^( +)/g, (match) => {
      return match.replace(/ /g, "&nbsp;");
    });
    processedLine = processedLine.replace(/ {2,}/g, (match) => {
      return match.replace(/ /g, "&nbsp;");
    });
    processedLine = processedLine.replace(/(["'`])(.*?)\1/g, (match, quote, content) => {
      const escapedContent = this.escapeHtml(content);
      return `${quote}<span class="code-snippet__string">${escapedContent}</span>${quote}`;
    });
    processedLine = processedLine.replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&grave;/g, "`");
    return processedLine;
  }
  escapeHtml(unsafe) {
    return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/#/g, "&#35;");
  }
};

/* nosourcemap */