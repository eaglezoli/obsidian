/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CopyImageTextPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var CopyImageTextPlugin = class extends import_obsidian.Plugin {
  async onload() {
    this.addCommand({
      id: "copy-text",
      name: "\u590D\u5236\u6587\u672C\u548C\u56FE\u7247(\u5BCC\u6587\u672C)",
      editorCallback: (editor, view) => this.copyTextAndImages(editor, view)
    });
    this.addCommand({
      id: "copy-markdown",
      name: "\u590D\u5236\u4E3AMarkdown\u683C\u5F0F",
      editorCallback: (editor, view) => this.copyAsMarkdown(editor, view)
    });
  }
  async copyTextAndImages(editor, view) {
    try {
      let content = editor.getSelection() || editor.getValue();
      if (!view.file) {
        new import_obsidian.Notice("\u65E0\u6CD5\u83B7\u53D6\u5F53\u524D\u6587\u4EF6\u4FE1\u606F\uFF0C\u590D\u5236\u53EF\u80FD\u4E0D\u5B8C\u6574");
        return;
      }
      const htmlContent = await this.convertToHtml(content, view.file);
      await navigator.clipboard.write([
        new ClipboardItem({
          "text/html": new Blob([htmlContent], { type: "text/html" }),
          "text/plain": new Blob([content], { type: "text/plain" })
        })
      ]);
      new import_obsidian.Notice("\u5185\u5BB9\u5DF2\u6210\u529F\u590D\u5236");
    } catch (error) {
      new import_obsidian.Notice("\u590D\u5236\u5931\u8D25\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5");
    }
  }
  async copyAsMarkdown(editor, view) {
    try {
      let content = editor.getSelection() || editor.getValue();
      if (!view.file) {
        new import_obsidian.Notice("\u65E0\u6CD5\u83B7\u53D6\u5F53\u524D\u6587\u4EF6\u4FE1\u606F\u590D\u5236\u53EF\u80FD\u4E0D\u5B8C\u6574");
        return;
      }
      content = await this.replaceImageLinks(content, view.file);
      await navigator.clipboard.writeText(content);
      new import_obsidian.Notice("Markdown\u683C\u5F0F\u5DF2\u590D\u5236");
    } catch (error) {
      new import_obsidian.Notice("\u590D\u5236\u5931\u8D25\uFF0C\u8BF7\u7A0D\u540E\u91CD\u8BD5");
    }
  }
  async replaceImageLinks(content, file) {
    const imageRegex = /!\[\[(.*?)\]\]/g;
    let result = content;
    for (const match of content.matchAll(imageRegex)) {
      const imagePath = match[1];
      const imageFile = this.app.vault.getFiles().find((f) => {
        var _a;
        return f.name.toLowerCase().includes(((_a = imagePath.split("/").pop()) == null ? void 0 : _a.toLowerCase()) || "");
      });
      if (imageFile) {
        let absolutePath = this.app.vault.getResourcePath(imageFile).replace(/^app:\/\/.*?\//, "").replace(/\?.*$/, "").replace(/\\/g, "/");
        absolutePath = decodeURI(absolutePath);
        const fileUrl = "file:///" + absolutePath;
        result = result.replace(`![[${imagePath}]]`, `![${imagePath}](${fileUrl})`);
      }
    }
    return result;
  }
  async convertToHtml(content, file) {
    const imageRegex = /!\[\[(.*?)\]\]/g;
    const replacements = await Promise.all(Array.from(content.matchAll(imageRegex)).map((match) => this.replaceImageWithBase64(match[1], file)));
    let htmlContent = content;
    replacements.forEach(({ original, replacement }) => {
      htmlContent = htmlContent.replace(original, replacement);
    });
    htmlContent = htmlContent.replace(/^---$/gm, '<hr style="border: 0; border-top: 1px solid #ddd; margin: 20px 0;">');
    htmlContent = htmlContent.replace(/```([\s\S]*?)```/g, (match, code) => {
      const escapedCode = this.escapeHtml(code.trim());
      return `<pre style="background-color: #f6f8fa; border-radius: 3px; padding: 16px; overflow: auto;"><code style="font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; font-size: 14px; line-height: 1.5;">${escapedCode}</code></pre>`;
    });
    htmlContent = htmlContent.replace(/^(#+)\s+(.*?)$/gm, (match, hashes, title) => {
      const level = hashes.length;
      const fontSize = 28 - level * 2;
      return `<h${level} style="font-size: ${fontSize}px; font-weight: bold; margin: 10px 0;">${title}</h${level}>`;
    });
    htmlContent = htmlContent.replace(/\n/g, "<br>").replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>").replace(/\*(.+?)\*/g, "<em>$1</em>").replace(/`(.+?)`/g, '<code style="background-color: #f0f0f0; padding: 2px 4px; border-radius: 3px;">$1</code>').replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2" style="color: #576b95; text-decoration: none;">$1</a>');
    return `<div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; color: #333; line-height: 1.6;">${htmlContent}</div>`;
  }
  async replaceImageWithBase64(imagePath, file) {
    try {
      const fileName = imagePath.split("/").pop() || imagePath;
      const imageFile = this.app.vault.getFiles().find((f) => f.name.toLowerCase().includes(fileName.toLowerCase()));
      if (!imageFile) {
        return { original: `![[${imagePath}]]`, replacement: `[\u56FE\u7247\u672A\u627E\u5230: ${imagePath}]` };
      }
      const stat = await this.app.vault.adapter.stat(imageFile.path);
      if (stat && stat.size > 10 * 1024 * 1024) {
        return { original: `![[${imagePath}]]`, replacement: `[\u56FE\u7247\u6587\u4EF6\u8FC7\u5927: ${imagePath}]` };
      }
      const imageArrayBuffer = await this.app.vault.readBinary(imageFile);
      const base64 = (0, import_obsidian.arrayBufferToBase64)(imageArrayBuffer);
      const mimeType = this.getMimeType(imagePath);
      return {
        original: `![[${imagePath}]]`,
        replacement: `<img src="data:${mimeType};base64,${base64}" alt="${imagePath}" style="max-width: 100%;">`
      };
    } catch (error) {
      return { original: `![[${imagePath}]]`, replacement: `[\u56FE\u7247\u5904\u7406\u9519\u8BEF: ${imagePath}]` };
    }
  }
  getMimeType(filename) {
    var _a;
    const ext = (_a = filename.split(".").pop()) == null ? void 0 : _a.toLowerCase();
    switch (ext) {
      case "jpg":
      case "jpeg":
        return "image/jpeg";
      case "png":
        return "image/png";
      case "gif":
        return "image/gif";
      case "webp":
        return "image/webp";
      case "svg":
        return "image/svg+xml";
      default:
        return "image/png";
    }
  }
  escapeHtml(unsafe) {
    return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
};


/* nosourcemap */